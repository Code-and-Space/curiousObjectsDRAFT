// body
let antoineBox1 = {
  rectX: 254,
  rectY: 125,

  originX: 254,
  originY: 125,

  rectWidth: 79,
  rectHeight: 285,
  speedX: 3,
  speedY: 2
}
let antoineBox2 = {
  rectX: 333,
  rectY: 158,

  originX: 333,
  originY: 158,

  rectWidth: 29,
  rectHeight: 91,
  speedX: 8,
  speedY: -1
}

let antoineBox3 = {
  rectX: 225,
  rectY: 158,

  originX: 225,
  originY: 158,

  rectWidth: 29,
  rectHeight: 91,
  speedX: -5,
  speedY: 3
}

let antoineBox4 = {
  rectX: 333,
  rectY: 272,

  originX: 333,
  originY: 272,

  rectWidth: 8,
  rectHeight: 61,
  speedX: -1,
  speedY: 8
}
let antoineBox5 = {
  rectX: 246,
  rectY: 272,

  originX: 246,
  originY: 272,

  rectWidth: 8,
  rectHeight: 61,
  speedX: 5,
  speedY: 4
}
let antoineBox6 = {
  rectX: 333,
  rectY: 355,

  originX: 333,
  originY: 355,

  rectWidth: 26,
  rectHeight: 31,
  speedX: -4,
  speedY: -3
}
let antoineBox7 = {
  rectX: 228,
  rectY: 355,

  originX: 228,
  originY: 355,

  rectWidth: 26,
  rectHeight: 31,
  speedX: 4,
  speedY: -8
}
let antoineTriangle01 = {
  X1: 125,
  Y1: 58,
  X2: 154,
  Y2: 58,
  X3: 154,
  Y3: 25,
  transX: 100,
  transY: 100,
  angle: 1,
  speed: 0.05
}
let antoineTriangle02 = {
  X1: 262,
  Y1: 58,
  X2: 233,
  Y2: 58,
  X3: 233,
  Y3: 25,
  transX: 100,
  transY: 100,
  angle: 1,
  speed: 0.05,
}

let antoineTriangle03 = {
  X1: 159,
  Y1: 186,
  X2: 133,
  Y2: 210,
  X3: 133,
  Y3: 186,
  transX: 200,
  transY: 200,
  angle: 1,
  speed: 0.05
}
let antoineTriangle04 = {
  X1: 28,
  Y1: 186,
  X2: 54,
  Y2: 210,
  X3: 54,
  Y3: 186,
  transX: 200,
  transY: 200,
  angle: 1,
  speed: 0.05
}
let antoineTriangle05 = {
  X1: 33,
  Y1: 55,
  X2: 33,
  Y2: 25,
  X3: 59,
  Y3: 55,
  transX: 300,
  transY: 300,
  angle: 1,
  speed: 0.05
}
let antoineTriangle06 = {
  X1: 54,
  Y1: 155,
  X2: 54,
  Y2: 125,
  X3: 28,
  Y3: 155,
  transX: 200,
  transY: 200,
  angle: 1,
  speed: 0.07
}
let antoineTriangle07 = {
  X1: 133,
  Y1: 49,
  X2: 133,
  Y2: 80,
  X3: 162,
  Y3: 49,
  transX: 200,
  transY: 200,
  angle: 1,
  speed: 0.075
}
let antoineTriangle08 = {
  X1: 54,
  Y1: 49,
  X2: 54,
  Y2: 80,
  X3: 25,
  Y3: 49,
  transX: 200,
  transY: 200,
  angle: 1,
  speed: 0.03
}

//arms
let antoineLine01 = {
  lineX1: 352,
  lineY1: 237,
  lineX2: 498,
  lineY2: 166
}
let antoineLine02 = {
  lineX1: 232,
  lineY1: 237,
  lineX2: 96,
  lineY2: 166
}
let antoineLine03 = {
  lineX1: 252,
  lineY1: 357,
  lineX2: 115,
  lineY2: 430
}
let antoineLine04 = {
  lineX1: 341,
  lineY1: 357,
  lineX2: 475,
  lineY2: 430
}

//rotors
let antoineCircle01 = {
  circleX:475,
  circleY:430,

  originX:475,
  originY:430,

  speedX: 5,
  speedY: 4

}
let antoineCircle02 = {
  circleX:96,
  circleY:166,

  originX:96,
  originY:166,

  speedX: 7,
  speedY: 5
}
let antoineCircle03 = {
  circleX:115,
  circleY:430,

  originX:115,
  originY:430,

  speedX: 3,
  speedY: -8
}
let antoineCircle04 = {
  circleX:498,
  circleY:166,

  originX:498,
  originY:166,

  speedX: -5,
  speedY: 3
}

//Blades
let antoineEllipse01 = {
  ellipseTransX:475,
  ellipseTransY:430,
  ellipserotate:-208
}

let antoineEllipse02 = {
  ellipseTransX:96,
  ellipseTransY:166,
  ellipserotate:-208
}

let antoineEllipse03 = {
  ellipseTransX:115,
  ellipseTransY:430,
  ellipserotate:-90
}

let antoineEllipse04 = {
  ellipseTransX:498,
  ellipseTransY:166,
  ellipserotate:-90
}


// let rectangles = [antoineBox1, antoineBox2, antoineBox3, antoineBox4, antoineBox5, antoineBox6, antoineBox7];
// let rectangleArray = [];
//
// let triangles = [antoineTriangle01, antoineTriangle02];
// let triangleArray = [];
//
// let lines = [antoineLine01, antoineLine02, antoineLine03, antoineLine04];
// let lineArray = [];
//
// let circles = [antoineCircle01, antoineCircle02, antoineCircle03, antoineCircle04];
// let circleArray = [];
//
// let ellipses = [antoineEllipse01, antoineEllipse02, antoineEllipse03, antoineEllipse04];
// let ellipseArray = [];


// consolidate into 1 array
// Your order in which you draw is important. Circles have to be above rectangles (and vice versa) to create the appropriate overlaps)
let antoineShapes = [antoineBox1, antoineBox2, antoineBox3, antoineBox4, antoineBox5, antoineBox6, antoineBox7, antoineTriangle01, antoineTriangle02, antoineTriangle03, antoineTriangle04, antoineTriangle05, antoineTriangle06, antoineTriangle07, antoineTriangle08, antoineLine01, antoineLine02, antoineLine03, antoineLine04, antoineCircle01, antoineCircle02, antoineCircle03, antoineCircle04, antoineEllipse01, antoineEllipse02, antoineEllipse03, antoineEllipse04];
let antoineShapesArray =[];


// This is to control the time it takes to run a full cycle.
let antoineShapesMultiplier = 1;

function setup(){

  createCanvas(600,600);
  angleMode(RADIANS);


  for (let i=0; i < antoineShapes.length; i++) {
    // Control speed of rectangles
    if (antoineShapes[i].transX === undefined && antoineShapes[i].lineX1 === undefined && antoineShapes[i].circleX === undefined && antoineShapes[i].ellipseTransX === undefined) {
      antoineShapes[i].speedX = antoineShapes[i].speedX * antoineShapesMultiplier
      antoineShapes[i].speedY = antoineShapes[i].speedY * antoineShapesMultiplier
    }

    // Control speed of triangles
    if (antoineShapes[i].rectX === undefined && antoineShapes[i].lineX1 === undefined && antoineShapes[i].circleX === undefined && antoineShapes[i].ellipseTransX === undefined) {
      antoineShapes[i].speed = antoineShapes[i].speed * antoineShapesMultiplier;
    }

    // Control speed of circles
    if (antoineShapes[i].rectX === undefined && antoineShapes[i].transX === undefined && antoineShapes[i].lineX1 === undefined && antoineShapes[i].ellipseTransX === undefined) {
      antoineShapes[i].speedX = antoineShapes[i].speedX * antoineShapesMultiplier
      antoineShapes[i].speedY = antoineShapes[i].speedY * antoineShapesMultiplier
    }

    antoineShapesArray[i] = new Drone(antoineShapes[i]);
  }
}

function draw(){
  background(255);
  fill(0)

  for (let i=0; i < antoineShapesArray.length; i++) { // your array name is rectangles, not boxes
    antoineShapesArray[i].drawGhostedDrone();
    antoineShapesArray[i].drawbox(); // AC Note: you're missing parenthesis
    antoineShapesArray[i].drawtriangle();
    antoineShapesArray[i].drawline();
    antoineShapesArray[i].drawcircle();
    antoineShapesArray[i].drawellipse();

    antoineShapesArray[i].tracingBox();
    antoineShapesArray[i].tracingCircle();

  }
}


class Drone {

  constructor (incomingShape) { // AC NOTE: I made a mistake on an earlier version. I will need to fix this.
    this.incomingShape = incomingShape;
  }
  // } // AC NOTE: you've closed off the class here. the rest of the code below is cut off from the class. I have commented out this curly bracket.

  // Method to draw ghosted drone
  drawGhostedDrone() {
    // Draw rectangles
    // In drawing a rect, I have to make sure the object is not a circle, line, ellipse, or triangle.
    // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
    if (this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      noStroke();
      fill(0, 0, 0, 20);
      push();
      translate(this.incomingShape.originX, this.incomingShape.originY)
      rect(0, 0, this.incomingShape.rectWidth, this.incomingShape.rectHeight);
      pop();
    }

    // Draw triangles
    // In drawing a triangle, I have to make sure the object is not a circle, line, ellipse, or rect.
    // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
    if (this.incomingShape.rectX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      noStroke();
      fill(0, 0, 0, 20);
      push();
      translate(this.incomingShape.transX, this.incomingShape.transY)
      triangle(this.incomingShape.X1, this.incomingShape.Y1, this.incomingShape.X2, this.incomingShape.Y2, this.incomingShape.X3, this.incomingShape.Y3)
      pop();
    }

    //Draw circle
    // In drawing a circle, I have to make sure the object is not a rect, line, ellipse, or triangle.
    // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
    if (this.incomingShape.rectX === undefined && this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.ellipseTransX === undefined) {
      noStroke();
      fill(0, 0, 0, 20);
      push();
      translate(this.incomingShape.originX, this.incomingShape.originY)
      circle (0, 0, 44);
      pop();
    }
  }

  // Method to draw rectangles
  // In drawing a rect, I have to make sure the object is not a circle, line, ellipse, or triangle.
  // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
  drawbox () {
    if (this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      push();
      fill(0);
      strokeWeight(0)
      if (this.incomingShape.rectX > 600 || this.incomingShape.rectX < 0) {
        // if (this.incomingShape.rectX + this.incomingShape.rectWidth > width || this.incomingShape.rectX < 0) {

        this.incomingShape.speedX = this.incomingShape.speedX*-1;
      }
      this.incomingShape.rectX = this.incomingShape.rectX + this.incomingShape.speedX;

      if (this.incomingShape.rectY > 600 || this.incomingShape.rectY < 0) {
        // if (this.incomingShape.rectY + this.incomingShape.rectHeight > height || this.incomingShape.rectY < 0) {

        this.incomingShape.speedY = this.incomingShape.speedY*-1;
      }
      this.incomingShape.rectY = this.incomingShape.rectY + this.incomingShape.speedY;

      translate(this.incomingShape.rectX, this.incomingShape.rectY)
      rect(0, 0, this.incomingShape.rectWidth, this.incomingShape.rectHeight);
      pop()
      // console.log(antoineBox1.rectY)

      if (this.incomingShape.rectX === this.incomingShape.originX && this.incomingShape.rectY === this.incomingShape.originY) {
        this.incomingShape.speedX = 0;
        this.incomingShape.speedY = 0;
      }
    }
  }

  // Method to draw triangles
  // In drawing a triangle, I have to make sure the object is not a circle, line, ellipse, or rect.
  // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
  drawtriangle (){
    fill(0);
    if (this.incomingShape.rectX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      push()
      strokeWeight(0)
      translate(this.incomingShape.transX, this.incomingShape.transY)
      rotate(this.incomingShape.angle)
      this.incomingShape.angle = this.incomingShape.angle + this.incomingShape.speed
      triangle(this.incomingShape.X1, this.incomingShape.Y1, this.incomingShape.X2, this.incomingShape.Y2, this.incomingShape.X3, this.incomingShape.Y3)
      pop()

      if (this.incomingShape.angle > 90) {
        this.incomingShape.speed = 0;
        this.incomingShape.angle = this.incomingShape.originAngle;
      }
    }
  }

  // Method to draw line
  drawline() {
    fill(0);

    if (this.incomingShape.rectX === undefined && this.incomingShape.transX === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      strokeWeight(25)
      stroke(0);
      line(this.incomingShape.lineX1, this.incomingShape.lineY1, this.incomingShape.lineX2, this.incomingShape.lineY2)
    }
  }

  //Draw circle
  // In drawing a circle, I have to make sure the object is not a rect, line, ellipse, or triangle.
  // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
  drawcircle (){
    fill(0);

    if (this.incomingShape.rectX === undefined && this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.ellipseTransX === undefined) {
      push()
      strokeWeight(0)
      if (this.incomingShape.circleX + 22 > 600 || this.incomingShape.circleX - 22 < 0) {
        this.incomingShape.speedX = this.incomingShape.speedX*-1;
      }
      this.incomingShape.circleX = this.incomingShape.circleX + this.incomingShape.speedX;

      if (this.incomingShape.circleY + 22 > 600 || this.incomingShape.circleY - 22 < 0) {
        this.incomingShape.speedY = this.incomingShape.speedY*-1;
      }
      this.incomingShape.circleY = this.incomingShape.circleY + this.incomingShape.speedY;

      translate(this.incomingShape.circleX, this.incomingShape.circleY)
      circle (0, 0, 44);
      pop()

      if (this.incomingShape.circleX === this.incomingShape.originX && this.incomingShape.circleY === this.incomingShape.originY) {
        this.incomingShape.speedX = 0;
        this.incomingShape.speedY = 0;
      }
    }
  }

  // Method to draw ellipse
  drawellipse (){
    fill(0);
    if (this.incomingShape.rectX === undefined && this.incomingShape.transX === undefined && this.incomingShape.circleX === undefined && this.incomingShape.lineX1 === undefined) {
      push();
      strokeWeight(0);
      translate(this.incomingShape.ellipseTransX, this.incomingShape.ellipseTransY);
      rotate (this.incomingShape.ellipserotate);
      this.incomingShape.ellipserotate = this.incomingShape.ellipserotate + 100;
      blade();
      pop()
    }
  }


  tracingBox () {
    if (this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      stroke(0, 0, 0, 50)
      strokeWeight(1)
      line (this.incomingShape.rectX + this.incomingShape.rectWidth / 2, 0, this.incomingShape.rectX + this.incomingShape.rectWidth / 2, height)
      line (0, this.incomingShape.rectY + this.incomingShape.rectHeight / 2, width, this.incomingShape.rectY + this.incomingShape.rectHeight / 2)
    }
  }

  tracingCircle () {
    if (this.incomingShape.rectX === undefined && this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.ellipseTransX === undefined) {
      stroke(0, 0, 0, 50)
      strokeWeight(1)
      line(this.incomingShape.circleX, 0, this.incomingShape.circleX, height)
      line(0, this.incomingShape.circleY, width, this.incomingShape.circleY)
    }
  }

  resetMovement() {
    if (this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      if (this.incomingShape.rectX === this.incomingShape.originX && this.incomingShape.rectY === this.incomingShape.originY) {
        this.incomingShape.speedX = getRandomInt(1, 10);
        this.incomingShape.speedY = getRandomInt(1, 10);
      }
    }

    if (this.incomingShape.rectX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.circleX === undefined && this.incomingShape.ellipseTransX === undefined) {
      if (this.incomingShape.speed === 0) {
        this.incomingShape.speed = 1;
        this.incomingShape.angle = 1;
      }
    }
    if (this.incomingShape.rectX === undefined && this.incomingShape.transX === undefined && this.incomingShape.lineX1 === undefined && this.incomingShape.ellipseTransX === undefined) {
      if (this.incomingShape.circleX === this.incomingShape.originX && this.incomingShape.circleY === this.incomingShape.originY) {
        this.incomingShape.speedX = getRandomInt(1, 10);
        this.incomingShape.speedY = getRandomInt(1, 10);
      }
    }
  }
}


function blade() {
  push()
  translate(0,60)
  ellipse(0,0,25,123);
  pop()
  push()
  translate(0,-60)
  ellipse(0,0,25,123);
  pop()
}
