let karimBox01 = {
  color: 'skyblue',
  rectX: 0,
  rectY: 0,
  rectWidth: 200,
  rectHeight: 100,
  transX: 300,
  transY: 300,

  originX: 300,
  originY: 300,

  speedX: 2.5,
  speedY: 2.5
}

let karimBox02 = {
  rectX: 0,
  rectY: 0,
  color: 'lightblue',
  rectWidth: 160,
  rectHeight: 25,
  transX: 300,
  transY: 262.5,

  originX: 300,
  originY: 262.5,

  speedX: 2,
  speedY: 2
}

let karimBox03 = {
  rectX: 0,
  rectY: 0,
  color: 'lightblue',
  rectWidth: 160,
  rectHeight: 25,
  transX: 300,
  transY: 287.5,

  originX: 300,
  originY: 287.5,

  speedX: 1.5,
  speedY: 1.5
}

let karimBox04 = {
  rectX: 0,
  rectY: 0,
  color: 'lightblue',
  rectWidth: 160,
  rectHeight: 25,
  transX: 300,
  transY: 312.5,

  originX: 300,
  originY: 312.5,

  speedX: 1,
  speedY: 1
}

let karimBox05 = {
  rectX: 0,
  rectY: 0,
  color: 'lightblue',
  rectWidth: 160,
  rectHeight: 25,
  transX: 300,
  transY: 337.5,

  originX: 300,
  originY: 337.5,

  speedX: .5,
  speedY: .5
}

let karimEllipse01 = {
  ellipseX: 0,
  ellipseY: 0,
  color: 'lightblue',
  ellipseWidth: 4,
  ellipseHeight: 4,
  transX: 213,
  transY: 257,

  originX: 213,
  originY: 257,

  speedX: .5,
  speedY: .5
}

let karimEllipse02 = {
  ellipseX: 0,
  ellipseY: 0,
  color: 'lightblue',
  ellipseWidth: 4,
  ellipseHeight: 4,
  transX: 213,
  transY: 343,

  originX: 213,
  originY: 343,

  speedX: .5,
  speedY: .5
}

let karimEllipse03 = {
  ellipseX: 0,
  ellipseY: 0,
  color: 'lightblue',
  ellipseWidth: 4,
  ellipseHeight: 4,
  transX: 387,
  transY: 257,

  originX: 387,
  originY: 257,

  speedX: .5,
  speedY: .5
}

let karimEllipse04 = {
  ellipseX: 0,
  ellipseY: 0,
  color: 'lightblue',
  ellipseWidth: 4,
  ellipseHeight: 4,
  transX: 387,
  transY: 343,

  originX: 387,
  originY: 343,

  speedX: .5,
  speedY: .5
}


let karimCurve01 = {
  p1X: 395,
  p1Y: 255,
  p2X: 395,
  p2Y: 255,
  p3X: 440,
  p3Y: 300,
  p4X: 440,
  p4Y: 325,

  originp1X: 395,
  originp1Y: 255,
  originp2X: 395,
  originp2Y: 255,
  originp3X: 440,
  originp3Y: 300,
  originp4X: 440,
  originp4Y: 325,

  transX: 0,
  transY: 0,

  speedX1: 1,
  speedY1: 1,
  speedX2: .5,
  speedY2: 2,
  speedX3: .5,
  speedY3: 1,
  speedX4: 1,
  speedY4: .5
}

let karimCurve02 = {
  p1X: 395,
  p1Y: 255,
  p2X: 440,
  p2Y: 300,
  p3X: 440,
  p3Y: 325,
  p4X: 395,
  p4Y: 345,

  originp1X: 395,
  originp1Y: 255,
  originp2X: 440,
  originp2Y: 300,
  originp3X: 440,
  originp3Y: 325,
  originp4X: 395,
  originp4Y: 345,

  transX: 0,
  transY: 0,
  speedX1: 1,
  speedY1: .5,
  speedX2: 1,
  speedY2: 2,
  speedX3: .5,
  speedY3: 1,
  speedX4: .5,
  speedY4: 1
}

let karimCurve03 = {
  p1X: 440,
  p1Y: 300,
  p2X: 440,
  p2Y: 325,
  p3X: 395,
  p3Y: 334,
  p4X: 395,
  p4Y: 345,

  originp1X: 440,
  originp1Y: 300,
  originp2X: 440,
  originp2Y: 325,
  originp3X: 395,
  originp3Y: 334,
  originp4X: 395,
  originp4Y: 345,

  transX: 0,
  transY: 0,
  speedX1: .5,
  speedY1: 1,
  speedX2: .5,
  speedY2: .5,
  speedX3: 1,
  speedY3: 1,
  speedX4: 2,
  speedY4: 1
}

let karimCurve04 = {
  p1X: 205,
  p1Y: 255,
  p2X: 205,
  p2Y: 255,
  p3X: 160,
  p3Y: 300,
  p4X: 160,
  p4Y: 325,

  originp1X: 205,
  originp1Y: 255,
  originp2X: 205,
  originp2Y: 255,
  originp3X: 160,
  originp3Y: 300,
  originp4X: 160,
  originp4Y: 325,

  transX: 0,
  transY: 0,
  speedX1: .5,
  speedY1: 2,
  speedX2: 1,
  speedY2: 1,
  speedX3: .5,
  speedY3: 1,
  speedX4: .5,
  speedY4: .5
}

let karimCurve05 = {
  p1X: 205,
  p1Y: 255,
  p2X: 160,
  p2Y: 300,
  p3X: 160,
  p3Y: 325,
  p4X: 205,
  p4Y: 345,

  originp1X: 205,
  originp1Y: 255,
  originp2X: 160,
  originp2Y: 300,
  originp3X: 160,
  originp3Y: 325,
  originp4X: 205,
  originp4Y: 345,

  transX: 0,
  transY: 0,
  speedX1: 1,
  speedY1: .5,
  speedX2: 1,
  speedY2: 1,
  speedX3: 1,
  speedY3: .5,
  speedX4: 2,
  speedY4: 1
}

let karimCurve06 = {
  p1X: 160,
  p1Y: 300,
  p2X: 160,
  p2Y: 325,
  p3X: 205,
  p3Y: 345,
  p4X: 205,
  p4Y: 345,

  originp1X: 160,
  originp1Y: 300,
  originp2X: 160,
  originp2Y: 325,
  originp3X: 205,
  originp3Y: 345,
  originp4X: 205,
  originp4Y: 345,

  transX: 0,
  transY: 0,
  speedX1: .5,
  speedY1: 1,
  speedX2: .5,
  speedY2: 1,
  speedX3: 2,
  speedY3: 1,
  speedX4: 1,
  speedY4: .5
}

// consolidate into 1 array
// Your order in which you draw is important. Circles have to be above rectangles (and vice versa) to create the appropriate overlaps)
let karimShapes = [karimBox01, karimBox02, karimBox03, karimBox04, karimBox05, karimEllipse01, karimEllipse02, karimEllipse03, karimEllipse04, karimCurve01, karimCurve02, karimCurve03, karimCurve04, karimCurve05, karimCurve06];
let karimShapePosition = [];

// This is to control the time it takes to run a full cycle.
let karimSpeedMulitplier = 2;

// let loops = [loop01, loop02]
// let loopPosition = [];

// function setup() {
//   createCanvas(600, 600);
//
//   for (let i = 0; i < karimShapes.length; i++) {
//     // Setting your speedX and speedY allows you to just look at the code when every shape is still
//     // karimShapes[i].speedX = 0;
//     // karimShapes[i].speedY = 0;
//
//     // karimShapes[i].speedX = karimShapes[i].speedX * karimSpeedMulitplier;
//     // karimShapes[i].speedY = karimShapes[i].speedY * karimSpeedMulitplier;
//
//     if (karimShapes[i].rectX === undefined && karimShapes[i].ellipseX === undefined) {
//       // This is where your speed multiplier adjusts the speedX and speedY
//       karimShapes[i].speedX1 = karimShapes[i].speedX1 * karimSpeedMulitplier;
//       karimShapes[i].speedY1 = karimShapes[i].speedY1 * karimSpeedMulitplier;
//       karimShapes[i].speedX2 = karimShapes[i].speedX2 * karimSpeedMulitplier;
//       karimShapes[i].speedY2 = karimShapes[i].speedY2 * karimSpeedMulitplier;
//       karimShapes[i].speedX3 = karimShapes[i].speedX3 * karimSpeedMulitplier;
//       karimShapes[i].speedY3 = karimShapes[i].speedY3 * karimSpeedMulitplier;
//       karimShapes[i].speedX4 = karimShapes[i].speedX4 * karimSpeedMulitplier;
//       karimShapes[i].speedY4 = karimShapes[i].speedY4 * karimSpeedMulitplier;
//
//     }
//     karimShapePosition[i] = new MovedBox(karimShapes[i]);
//   }
//   //  for (let i = 0; i < loops.length; i++){
//   //    loops[i].speedX = 0;
//   //    loops[i].speedY = 0;
//   //  loopPosition[i] = new Loop(loops[i]);
//   // }
//
// }
//
// function draw() {
//   background(0);
//   rectMode(CENTER);
//
//   for (i = 0; i < karimShapes.length; i++) {
//     karimShapePosition[i].ghostedMask();
//     karimShapePosition[i].moveBox();
//     karimShapePosition[i].moveEllipse();
//     karimShapePosition[i].moveCurve();
//
//     // karimShapePosition[i].trackingLines();
//   }
//
//   // for (i = 0; i < loops.length; i++){
//   //
//   //   push();
//   //   loopPosition[i].drawLoop();
//   //   loopPosition[i].trackingLines();
//   //   loopPosition[i].moveX();
//   //   loopPosition[i].moveY();
//   //   pop();
//   //
//   // }
//
// }




class MovedBox {
  constructor (incomingShape) {
    this.incomingShape = incomingShape;
  }

  // Draw ghosted mask
  ghostedMask() {
    // Draw rectangles
    // In drawing a rect, I have to make sure the object is not a circle or curve.
    // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
    if (this.incomingShape.ellipseX === undefined && this.incomingShape.p1X === undefined) {
      stroke(0, 0, 0, 50);
      fill(255, 255, 255, 20);
      strokeWeight(2)
      push();
      translate(this.incomingShape.originX, this.incomingShape.originY);
      rect(this.incomingShape.rectX, this.incomingShape.rectY, this.incomingShape.rectWidth, this.incomingShape.rectHeight);
      pop();
    }

    // Draw ellipses
    // In drawing an ellipse, I have to make sure the object is not a rectangle or curve.
    // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
    if (this.incomingShape.rectX === undefined && this.incomingShape.p1X === undefined) {
      stroke(0, 0, 0, 50);
      fill(255, 255, 255, 20);
      strokeWeight(2);

      push();
      translate(this.incomingShape.originX, this.incomingShape.originY);
      ellipse(this.incomingShape.ellipseX, this.incomingShape.ellipseY, this.incomingShape.ellipseWidth, this.incomingShape.ellipseHeight);
      pop();
    }

    // Draw curves
    // In drawing a rect, I have to make sure the object is not a circle or rectangle.
    // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
    if (this.incomingShape.rectX === undefined && this.incomingShape.ellipseX === undefined) {
      stroke(255, 255, 255, 50);
      // fill(255, 255, 255, 20);
      strokeWeight(3);

      push();
      translate(this.incomingShape.transX, this.incomingShape.transY);
      curve(this.incomingShape.originp1X, this.incomingShape.originp1Y, this.incomingShape.originp2X, this.incomingShape.originp2Y, this.incomingShape.originp3X, this.incomingShape.originp3Y, this.incomingShape.originp4X, this.incomingShape.originp4Y)
      pop();
    }
  }

  // Method to draw rectangles
  // In drawing a rect, I have to make sure the object is not a circle or curve.
  // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
  moveBox() {
    if (this.incomingShape.ellipseX === undefined && this.incomingShape.p1X === undefined) {
      push();
      if (this.incomingShape.transX > 600 || this.incomingShape.transX < 0) {
        this.incomingShape.speedX = this.incomingShape.speedX*-1;
      }
      this.incomingShape.transX = this.incomingShape.transX + this.incomingShape.speedX;
      if (this.incomingShape.transY > 600 || this.incomingShape.transY < 0) {
        this.incomingShape.speedY = this.incomingShape.speedY*-1;
      }
      this.incomingShape.transY = this.incomingShape.transY + this.incomingShape.speedY;
      translate(this.incomingShape.transX, this.incomingShape.transY);

      stroke(255);
      strokeWeight(2)
      fill(this.incomingShape.color);
      rect(this.incomingShape.rectX, this.incomingShape.rectY, this.incomingShape.rectWidth, this.incomingShape.rectHeight);
      pop();

      // Below, if the values are equal again, then stop (speedX and speedY = 0).
      if (this.incomingShape.transX === this.incomingShape.originX && this.incomingShape.transY === this.incomingShape.originY) {
        this.incomingShape.speedX = 0;
        this.incomingShape.speedY = 0;
      }
    }
  }

  // Method to draw ellipses
  // In drawing an ellipse, I have to make sure the object is not a rectangle or curve.
  // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
  moveEllipse() {
    if (this.incomingShape.rectX === undefined && this.incomingShape.p1X === undefined) {
      push();
      if (this.incomingShape.transX > 600 || this.incomingShape.transX < 0) {
        this.incomingShape.speedX = this.incomingShape.speedX*-1;
      }
      this.incomingShape.transX = this.incomingShape.transX + this.incomingShape.speedX;
      if (this.incomingShape.transY > 600 || this.incomingShape.transY < 0) {
        this.incomingShape.speedY = this.incomingShape.speedY*-1;
      }
      this.incomingShape.transY = this.incomingShape.transY + this.incomingShape.speedY;
      translate(this.incomingShape.transX, this.incomingShape.transY);

      stroke(255);
      strokeWeight(2)
      fill(this.incomingShape.color);
      ellipse(this.incomingShape.ellipseX, this.incomingShape.ellipseY, this.incomingShape.ellipseWidth, this.incomingShape.ellipseHeight);
      pop();

      // Below, if the values are equal again, then stop (speedX and speedY = 0).
      if (this.incomingShape.transX === this.incomingShape.originX && this.incomingShape.transY === this.incomingShape.originY) {
        this.incomingShape.speedX = 0;
        this.incomingShape.speedY = 0;
      }

    }
  }

  // Method to draw curves
  // In drawing a rect, I have to make sure the object is not a circle or rectangle.
  // This is done with a conditional statement. If the JS Object does not have an other the other names, then the JS Object is a rect.
  moveCurve() {
    if (this.incomingShape.rectX === undefined && this.incomingShape.ellipseX === undefined) {
      stroke(255);
      strokeWeight(3);

      if (this.incomingShape.p1X > 600 || this.incomingShape.p1X < 0) {
        this.incomingShape.speedX1 = this.incomingShape.speedX1*-1;
      }
      this.incomingShape.p1X = this.incomingShape.p1X + this.incomingShape.speedX1;

      if (this.incomingShape.p1Y > 600 || this.incomingShape.p1Y < 0) {
        this.incomingShape.speedY1 = this.incomingShape.speedY1*-1;
      }
      this.incomingShape.p1Y = this.incomingShape.p1Y + this.incomingShape.speedY1;

      if (this.incomingShape.p2X > 600 || this.incomingShape.p2X < 0) {
        this.incomingShape.speedX2 = this.incomingShape.speedX2*-1;
      }
      this.incomingShape.p2X = this.incomingShape.p2X + this.incomingShape.speedX2;

      if (this.incomingShape.p2Y > 600 || this.incomingShape.p2Y < 0) {
        this.incomingShape.speedY2 = this.incomingShape.speedY2*-1;
      }
      this.incomingShape.p2Y = this.incomingShape.p2Y + this.incomingShape.speedY2;

      if (this.incomingShape.p3X > 600 || this.incomingShape.p3X < 0) {
        this.incomingShape.speedX3 = this.incomingShape.speedX3*-1;
      }
      this.incomingShape.p3X = this.incomingShape.p3X + this.incomingShape.speedX3;

      if (this.incomingShape.p3Y > 600 || this.incomingShape.p3Y < 0) {
        this.incomingShape.speedY3 = this.incomingShape.speedY3*-1;
      }
      this.incomingShape.p3Y = this.incomingShape.p3Y + this.incomingShape.speedY3;

      if (this.incomingShape.p4X > 600 || this.incomingShape.p4X < 0) {
        this.incomingShape.speedX4 = this.incomingShape.speedX4*-1;
      }
      this.incomingShape.p4X = this.incomingShape.p4X + this.incomingShape.speedX4;

      if (this.incomingShape.p4Y > 600 || this.incomingShape.p4Y < 0) {
        this.incomingShape.speedY4 = this.incomingShape.speedY4*-1;
      }
      this.incomingShape.p4Y = this.incomingShape.p4Y + this.incomingShape.speedY4;

      push();
      translate(this.incomingShape.transX, this.incomingShape.transY);
      curve(this.incomingShape.p1X, this.incomingShape.p1Y, this.incomingShape.p2X, this.incomingShape.p2Y, this.incomingShape.p3X, this.incomingShape.p3Y, this.incomingShape.p4X, this.incomingShape.p4Y)
      pop();

      // Below, if the values are equal again, then stop (speedX and speedY = 0).
      if (this.incomingShape.p1X === this.incomingShape.originp1X && this.incomingShape.p1Y === this.incomingShape.originp1Y) {
        this.incomingShape.speedX1 = 0;
        this.incomingShape.speedY1 = 0;
      }

      if (this.incomingShape.p2X === this.incomingShape.originp2X && this.incomingShape.p2Y === this.incomingShape.originp2Y) {
        this.incomingShape.speedX2 = 0;
        this.incomingShape.speedY2 = 0;
      }

      if (this.incomingShape.p3X === this.incomingShape.originp3X && this.incomingShape.p3Y === this.incomingShape.originp3Y) {
        this.incomingShape.speedX3 = 0;
        this.incomingShape.speedY3 = 0;
      }

      if (this.incomingShape.p4X === this.incomingShape.originp4X && this.incomingShape.p4Y === this.incomingShape.originp4Y) {
        this.incomingShape.speedX4 = 0;
        this.incomingShape.speedY4 = 0;
      }
    }
  }

  trackingLines() {
    stroke(255);
    strokeWeight(1.5)
    line(this.incomingShape.transX, 0,this.incomingShape.transX, height)
    line(0, this.incomingShape.transY, height, this.incomingShape.transY)
  }
}
